(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{493:function(t,s,a){"use strict";a.r(s);var _=a(2),r=Object(_.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("在如下例中")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("list = [1, 2, 3, 4, 5]\nset1 = set(list)\nprint(list(set1))\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("在执行的时候，会发现会报一个'list' object is not callable的错误，意思就是“list”对象不可调用，这是由于变量名和内置函数list()发生冲突，也就是之前有说过标识符名称要避开内置函数这些的名字。")]),t._v(" "),s("p",[t._v("那么在python里面是如何进行判断的呢？是有一个叫命名空间的东西")]),t._v(" "),s("h2",{attrs:{id:"一-命名空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一-命名空间"}},[t._v("#")]),t._v(" 一，命名空间")]),t._v(" "),s("p",[t._v("定义：是一个从名称到对象的映射，大部分以字典形式实现")]),t._v(" "),s("p",[t._v("作用：在项目中避免名字发生冲突，不过两个不同的命名空间是可以一样没关系的")]),t._v(" "),s("h3",{attrs:{id:"_1-内置命名空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-内置命名空间"}},[t._v("#")]),t._v(" 1，内置命名空间")]),t._v(" "),s("p",[t._v("像标识符要避开的内置对象这些，就是在"),s("strong",[t._v("内置命名空间")]),t._v("中，内置命名空间在解释器启动时即创建，持续到解释器终止")]),t._v(" "),s("p",[t._v("使用dir()可以返回传入对象的属性和方法列表，未传入时默认返回当前范围的所有变量、方法和定义的类型列表")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("print(dir())\nprint(dir(list))\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h3",{attrs:{id:"_2-全局命名空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-全局命名空间"}},[t._v("#")]),t._v(" 2，全局命名空间")]),t._v(" "),s("p",[t._v("在某个模块被读入的时候创建，直到解释器终止，包含模块中定义的名称，如变量、函数、类、其他导入的模块等")]),t._v(" "),s("h3",{attrs:{id:"_3-局部命名空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-局部命名空间"}},[t._v("#")]),t._v(" 3，局部命名空间")]),t._v(" "),s("p",[t._v("在函数被调用时创建，直到函数结束，包含这个函数中定义的名称，如变量、参数等")]),t._v(" "),s("h3",{attrs:{id:"_4-命名空间查找顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-命名空间查找顺序"}},[t._v("#")]),t._v(" 4，命名空间查找顺序")]),t._v(" "),s("p",[t._v("程序在执行的时候，会按照局部>全局>内置的顺序，如果在局部找不到的时候，就会去全局去找，然后再去内置去找")]),t._v(" "),s("p",[t._v("所以在具体使用的时候要注意可能某个变量只属于局部，就不能在全局去用，全局的一个变量要注意在局部里面是否会发生冲突")]),t._v(" "),s("p",[t._v("如在开头的那个例子中，在执行最后一句的时候，会优先去找全局里面定义的list，会找到是一个列表变量名，没法在后面接一个列表变量名，而不是在内置命名空间里去找list()方法")]),t._v(" "),s("h2",{attrs:{id:"二-作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二-作用域"}},[t._v("#")]),t._v(" 二，作用域")]),t._v(" "),s("p",[t._v("那么理解了底层的命名空间，再给能够访问这些命名空间的代码的区域给个名，叫作用域。例如能够访问局部命名空间的代码区域叫局部作用域。")]),t._v(" "),s("p",[t._v("具体分类（依次增大）：")]),t._v(" "),s("ul",[s("li",[t._v("局部作用域")]),t._v(" "),s("li",[t._v("闭包函数外的函数中")]),t._v(" "),s("li",[t._v("全局作用域")]),t._v(" "),s("li",[t._v("内建作用域")])]),t._v(" "),s("p",[t._v("作用：在当前作用域找不到对应名称的时候，去更高一级的作用域去找")])])}),[],!1,null,null,null);s.default=r.exports}}]);